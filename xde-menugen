#!/usr/bin/perl

# in case we get executed (not sourced) as a shell program
eval 'exec perl -S $0 ${1+"@"}'
    if $running_under_some_shell;

BEGIN {
    use strict;
    use warnings;
    my $here = $0; $here =~ s{/[^/]*$}{};
    if ($here =~ s{^\.}{}) {
	chomp(my $cwd = `pwd`);
	$here = "/$here" if $here;
	$here = "$cwd$here";
    }
    unshift @INC, "$here/lib" unless $here =~ m{^/usr/bin};
}

=head1 NAME

 xde-menugen -- generate XDG compliant menus

=head1 SYNOPSIS

 xde-menugen [ OPTIONS ]

=head1 DESCRIPTION

B<xde-menugen> is a command-line program that can be used to generate a
XDG compliant menu in a number of formats to support configuration of
the root menu for light-weight window managers.

B<xde-menugen> is capable of generating either a complete menu for a
number of well-known window managers, or for generating a submenu that
can be included in the root menu of those window managers.

=cut

use XDG::Menu::Parser;
use XDG::Menu::Fluxbox;
use XDG::Menu::Blackbox;
use XDG::Menu::Icewm;
use XDG::Menu::Wmaker;
use XDG::Menu::Jwm;
use XDG::Menu::Pekwm;
use Getopt::Long;
use Encode;
use I18N::Langinfo qw(langinfo CODESET);
use POSIX qw(locale_h);
use strict;
use warnings;

my %OVERRIDES = ();
my $here = $0; $here =~ s{/[^/]*$}{};
if ($here =~ s{^\.}{}) {
    chomp(my $cwd = `pwd`);
    $here = "/$here" if $here;
    $here = "$cwd$here";
}
unless ($here =~ m{^/usr/bin}) {
    %OVERRIDES = (
	HERE               => "$here",
	XDG_CONFIG_PREPEND => "$here/xdg/xde:$here/xdg",
	XDG_DATA_PREPEND   => "$here/share/xde:$here/share",
	XDG_ICON_APPEND    => "$here/share/icons:$here/share/pixmaps",
    );
    my %path = (map{$_=>1}split(/:/,$ENV{PATH}));
    $ENV{PATH} = "$here:$ENV{PATH}" unless exists $path{$here};
}

my $HOME = $ENV{HOME} if $ENV{HOME};
$HOME = '~' unless $HOME;

my $XDG_CURRENT_DESKTOP = $ENV{XDG_CURRENT_DESKTOP} if $ENV{XDG_CURRENT_DESKTOP};
$XDG_CURRENT_DESKTOP = '' unless $XDG_CURRENT_DESKTOP;
$ENV{XDG_CURRENT_DESKTOP} = $XDG_CURRENT_DESKTOP if $XDG_CURRENT_DESKTOP;

my $XDG_CONFIG_HOME = $ENV{XDG_CONFIG_HOME} if $ENV{XDG_CONFIG_HOME};
$XDG_CONFIG_HOME = "$HOME/.config" unless $XDG_CONFIG_HOME;
$ENV{XDG_CONFIG_HOME} = $XDG_CONFIG_HOME if $XDG_CONFIG_HOME;

my $XDG_CONFIG_DIRS = $ENV{XDG_CONFIG_DIRS} if $ENV{XDG_CONFIG_DIRS};
$XDG_CONFIG_DIRS = "/etc/xdg" unless $XDG_CONFIG_DIRS;
$ENV{XDG_CONFIG_DIRS} = $XDG_CONFIG_DIRS if $XDG_CONFIG_DIRS;

my @XDG_CONFIG_DIRS = (split(/:/,join(':',$XDG_CONFIG_HOME,$XDG_CONFIG_DIRS)));

my $XDG_DATA_HOME = $ENV{XDG_DATA_HOME} if $ENV{XDG_DATA_HOME};
$XDG_DATA_HOME = "$HOME/.local/share" unless $XDG_DATA_HOME;
$ENV{XDG_DATA_HOME} = $XDG_DATA_HOME if $XDG_DATA_HOME;

my $XDG_DATA_DIRS = $ENV{XDG_DATA_DIRS} if $ENV{XDG_DATA_DIRS};
$XDG_DATA_DIRS = "/usr/local/share:/usr/share" unless $XDG_DATA_DIRS;
$ENV{XDG_DATA_DIRS} = $XDG_DATA_DIRS if $XDG_DATA_DIRS;

my @XDG_DATA_DIRS = (split(/:/,join(':',$XDG_DATA_HOME,$XDG_DATA_DIRS)));

my $XDG_MENU_PREFIX = $ENV{XDG_MENU_PREFIX} if $ENV{XDG_MENU_PREFIX};
$XDG_MENU_PREFIX = '' unless $XDG_MENU_PREFIX;
$ENV{XDG_MENU_PREFIX} = $XDG_MENU_PREFIX if $XDG_MENU_PREFIX;

my $XDG_MENU_NAME = 'applications';

my @XDG_MENU_DIRS = map {"$_/menus"} @XDG_CONFIG_DIRS;

my $XDG_ROOT_MENU = '';
foreach my $name (
        "${XDG_MENU_PREFIX}${XDG_MENU_NAME}.menu",
        "${XDG_MENU_NAME}.menu") {
    foreach (@XDG_MENU_DIRS) {
        if (-f "$_/$name") {
            $XDG_ROOT_MENU = "$_/$name";
            last;
        }
    }
    last if $XDG_ROOT_MENU;
}

my $XDG_ICON_THEME = $ENV{XDG_ICON_THEME} if $ENV{XDG_ICON_THEME};
unless ($XDG_ICON_THEME) {
    if (-f "$HOME/.gtkrc-2.0") {
        my @lines = (`cat $ENV{HOME}/.gtkrc-2.0`);
        foreach (@lines) { chomp;
            if (m{gtk-icon-theme-name=["]?(.*[^"])["]?$}) {
                $XDG_ICON_THEME = "$1";
                last;
            }
        }
    } else {
        $XDG_ICON_THEME = 'hicolor';
    }
}
$ENV{XDG_ICON_THEME} = $XDG_ICON_THEME if $XDG_ICON_THEME;

my $XDG_ICON_DIRS = join(':',"$HOME/.icons",map {"$_/icons"} @XDG_DATA_DIRS,'/usr/share/pixmaps');
my @XDG_ICON_DIRS = split(/:/,$XDG_ICON_DIRS);

my %outputs = (
    fluxbox     => [ "$HOME/.fluxbox/menu" ],
    blackbox    => [ "$HOME/.blackbox/menu", "$HOME/.bbmenu" ],
    openbox     => [ "$HOME/.openbox/menu", "$HOME/.config/openbox/menu" ],
    icewm       => [ "$HOME/.icewm/menu" ],
    jwm         => [ "$HOME/.jwm/menu" ],
    pekwm       => [ "$HOME/.pekwm/menu" ],
);

my %formats = (
    fluxbox     => [qw(FLUXBOX  XDG::Menu::Fluxbox  )],
    blackbox    => [qw(BLACKBOX XDG::Menu::Blackbox )],
    openbox     => [qw(OPENBOX  XDG::Menu::Openbox  )],
    icewm       => [qw(ICEWM    XDG::Menu::Icewm    )],
    openbox3    => [qw(LXDE     XDG::Menu::Openbox3 )],
    wmaker      => [qw(WMAKER   XDG::Menu::Wmaker   )],
    jwm         => [qw(JWM      XDG::Menu::Jwm      )],
    pekwm       => [qw(PEKWM    XDG::Menu::Pekwm    )],
);

my %desktops = (
    FLUXBOX     => [qw(fluxbox  XDG::Menu::Fluxbox  )],
    BLACKBOX    => [qw(blackbox XDG::Menu::Blackbox )],
    WMAKER      => [qw(wmaker   XDG::Menu::Wmaker   )],
    OPENBOX     => [qw(openbox  XDG::Menu::Openbox  )],
    LXDE        => [qw(openbox3 XDG::Menu::Openbox3 )],
    ICEWM       => [qw(icewm    XDG::Menu::Icewm    )],
    JWM         => [qw(jwm      XDG::Menu::Jwm      )],
    PEKWM       => [qw(pekwm    XDG::Menu::Pekwm    )],
);

=head1 OPTIONS

=over

=item B<--help>,B<-h>

Print usage information, including the current values of option
defaults, and exit.

=item B<--verbose>,B<-v>

Print debugging information on standard error during operation.

=item B<--format>,B<-f> I<FORMAT>

Specify the output format.  Recognized output formats are as follows:
C<twm>, C<wmaker>, C<fvwm2>, C<ion3>, C<blackbox>, C<fluxbox>,
C<openbox>, C<xfce4>, C<openbox3>, C<openbox3-pipe>, C<awesome>.

When unspecified, the setting of the B<XDG_CURRENT_DESKTOP> environment
variable is used to determine the format.  This is accomplished by
converting the value of B<XDG_CURRENT_DESKTOP> to  lower-case.  See
L</ENVIRONMENT>.

=item B<--fullmenu>,B<-F>

When specified, output a full menu and not only a submenu.  The default
behaviour is to only output a submenu.

=item B<--desktop>,B<-d> I<DESKTOP>

Specify the desktop name for C<NotShowIn> and C<OnlyShowIn> comparisons.
The default is the all upper-case value corresponding to the format
unless C<XDG_CURRENT_DESKTOP> is defined (see L</ENVIRONMENT>).

=item B<--charset>,B<-c> I<CHARSET>

Specify the character set with which to output the menu.  Defaults to
the character set in use by the current locale.

=item B<--language>,B<-l> I<LANGUAGE>

Specify the output language for the menu.  Defaults to the language set
in the current locale.

=item B<--root-menu>,B<-r> I<MENU>

Specify the location of the root menu file.  The default is calculated
using XDG environment variables (see L</ENVIRONMENT>), and defaults to
the file F<${XDG_MENU_PREFIX}applications.menu> in the
F<$XDG_CONFIG_HOME:$XDG_CONFIG_DIRS> search path.

=item B<--die-on-error>,B<-e>

Abort execution on any error.

=item B<--output>,B<-o> [I<FILENAME>]

Write output to the file, I<FILENAME>, instead of to standard output.
This is particularly useful with option B<-die-on-error> as the output
will not be written at all if an error is encountered.  If the
I<FILENAME> is not specified, the default menu location for the
current B<-format> will be used.

=item B<--noicons>,B<-n>

Do not include icons in the generated menu files.  This option has no
effect when it is not possible to generate icons for the menu format.
That is, when the B<-format> is one such as C<blackbox>, it is not
possible to place icons in the menu and this option is therefore
ignored.  The default is to place icons in capable generated menus.

=item B<--theme>,B<-t> THEME

Specify the icon theme name to use when generating icons.  The default
is to obtain the icon theme name from default locations (such as the
F<$HOME/.gtkrc-2.0> file).

=item B<--monitor>,B<-m>

Specifies that B<xde-menugen> is not to exit after successfully
generating the menu, but to monitor pertinent directories for changes,
and regenerate the menu when changes are detected.  This option implies
the B<--output> option.  This option requires L<Linux::Inotify2(3pm)>.

=back

=cut

my %ops = (
    help        => '',
    format      => "\L$XDG_CURRENT_DESKTOP\E",
    fullmenu    => '',
    desktop     => "$XDG_CURRENT_DESKTOP",
    charset     => langinfo(CODESET),
    language    => setlocale(LC_MESSAGES),
    root_menu   => $XDG_ROOT_MENU,
    die_on_error=> '',
    verbose     => '',
    output      => '',
    icons       => '',
    noicons     => '',
    theme       => $XDG_ICON_THEME,
    monitor     => '',
);

my $syntax = GetOptions(
    "help|h"        =>\$ops{help},
    "format|f=s"    =>\$ops{format},
    "fullmenu|F"    =>\$ops{fullmenu},
    "desktop|d=s"   =>\$ops{desktop},
    "charset|c=s"   =>\$ops{charset},
    "language|l=s"  =>\$ops{language},
    "root-menu|r=s" =>\$ops{root_menu},
    "die-on-error|e"=>\$ops{die_on_error},
    "verbose|v"     =>\$ops{verbose},
    "output|o:s"    =>\$ops{output},
    "icons!"        =>\$ops{icons},
    "n"             =>sub{$ops{icons} = 0},
    "theme|t=s"     =>\$ops{theme},
    "monitor|m"     =>\$ops{monitor},
);

if ($ops{output} eq '') {
    if (exists $outputs{$ops{format}}) {
        foreach (@{$outputs{$ops{format}}}) {
            if (-f $_) {
                $ops{output} = $_;
                last;
            }
        }
    }
}

if ($ops{root_menu} and not -f $ops{root_menu}) {
    $ops{root_menu} = $XDG_ROOT_MENU
        if $XDG_ROOT_MENU and -f $XDG_ROOT_MENU;
}

unless ($ops{format}) {
    $ops{format} = $desktops{$ops{desktop}}[0]
        if $ops{desktop} and $desktops{$ops{desktop}};
}
unless ($ops{desktop}) {
    $ops{desktop} = $formats{$ops{format}}[0]
        if $ops{format} and $formats{$ops{format}};
}

if ($ops{help} or not $syntax) {
    usage($syntax ? 0 : 2);
}

unless ($ops{root_menu} and -f $ops{root_menu}) {
    print STDERR "bad root menu $ops{root_menu}\n" if $ops{root_menu};
    print STDERR "missing root menu\n" unless $ops{root_menu};
    usage(2);
}

unless ($ops{format} and exists $formats{$ops{format}}) {
    print STDERR "bad format $ops{format}\n" if $ops{format};
    print STDERR "missing format\n" unless $ops{format};
    usage(2);
}

unless ($ops{desktop} and exists $desktops{$ops{desktop}}) {
    print STDERR "bad desktop $ops{desktop}\n" if $ops{desktop};
    print STDERR "missing desktop\n" unless $ops{desktop};
    usage(2);
}

if (($ops{desktop} ne $formats{$ops{format}}[0]) or
    ($ops{format} ne $desktops{$ops{desktop}}[0])) {
    print STDERR "mismatch between format $ops{format} and desktop $ops{desktop}\n";
    usage(2);
}

if ($ops{theme}) {
    my $theme = '';
    foreach (@XDG_ICON_DIRS) {
        $theme = $ops{theme} if -f "$_/$ops{theme}/index.theme";
        last if $theme;
    }
    unless ($theme) {
        print STDERR "invalid theme $ops{theme}\n";
        usage(2);
    }
}
else {
    print STDERR "missing theme\n";
    usage(2);
}

$ops{lang} = $ops{language};
$ops{lang} =~ s/\..*$//;

if ($ops{verbose}) {
    print STDERR "\tRoot menu: $ops{root_menu}\n";
    print STDERR "\tFormat:    $ops{format}\n";
    print STDERR "\tDesktop:   $ops{desktop}\n";
    print STDERR "\tTheme:     $ops{theme}\n";
    print STDERR "\tCharset:   $ops{charset}\n";
    print STDERR "\tLanguage:  $ops{language}\n";
    print STDERR "\tLang:      $ops{lang}\n";
}

my $parser = new XDG::Menu::Parser;
my $tree = $parser->parse_menu($ops{root_menu});
my $builder = $formats{$ops{format}}[1];
my $wm = $builder->new();
print $wm->create($tree);
exit (0);


sub usage {
    my $retval = shift;
    print STDERR<<EOF;
USAGE:
    xde-menugen [OPTIONS]

OPTIONS:
    --help,-h
        print this usage info and exit

    --format,-f FORMAT      [default: $ops{format}]
        specify the output format to use; defaults to the lowercase
        value of XDG_CURRENT_DESKTOP.

    --fullmenu,-F
        generate a full menu instead of a submenu; default is to
        generate a submenu.

    --desktop,-d DESKTOP    [default: $ops{desktop}]
        specify the desktop string for OnlyShowIn and NotShowIn desktop
        entries; defaults is XDG_CURRENT_DESKTOP or the uppercase FORMAT
        value.

    --charset,-c CHARSET    [default: $ops{charset}]
        specify the character set to use to output the menu; defaults to
        the charset of the current locale.

    --language,-l LANGUAGE  [default: $ops{language}]
        specify the language to use to output the menu; defaults to the
        value of the current locale.

    --root-menu,-r ROOTMENU [default: $ops{root_menu}]
        specify the root menu.  Default is derived from XDG_MENU_PREFIX
        and XDG_CONFIG_DIRS.

    --die-on-error,-e
        abort (do not write output) on any error.

    --verbose,-v
        print debugging information on standard error.

    --output,-o [FILENAME]  [default: $ops{output}]
        print the output to file, FILENAME; default is to print the menu
        to standard output; default FILENAME if unspecified based on
        format.

    --noicons,-n
        do not include icons in the generated menu; default is to
        include icons in capable menus.

    --theme,-t THEME        [default: $ops{theme}]
        use the specified icon theme when generating icons; defaults to
        the user icon theme.

    --monitor,-m
        do not exit after first menu generation, but monitor pertinent
        directories for changes and regenerate the menu when required;
        implies the --output option.
EOF
    exit($retval);
}

=head1 ENVIRONMENT

The following environment variables are significant to the operation of
B<xde-menugen>:

=over

=item B<XDG_CURRENT_DESKTOP>

Specifies the current desktop.  When the B<--format> is not specified,
the format defaults to the value of this environment variable converted
to lower-case.  When the B<--desktop> is not specified, the desktop
defaults to the value of this environment variable.

=item B<XDG_MENU_PREFIX>

Specifies the prefix to apply to the default menu name to derive the
root menu unless specified with B<--root-menu>.  When unspecified, this
variable defaults to a null string.

B<xde-menugen> finds the root menu using the following logic:

=over

=item 1.

If a file name is specified using the B<--root-menu> option, that file
name is used as the root menu.

=item 2.

If not found, the file name F<${XGD_MENU_PREFIX}application.menu> is
sought in each of the directories in the path F<@XDG_CONFIG_DIRS/menus>.

=item 3.

If not found, the file name F<application.menu> is sought in each of the
directories in the path F<@XDG_CONFIG_DIRS/menus>.

=back

=item B<XDG_CONFIG_HOME>

Specifies the user configuration directory in accordance with XDG
specifications.  When unspecified, this variable defaults to
F<$HOME/.config> in accordance with XDG specifications.

=item B<XDG_CONFIG_DIRS>

Specifies the system configuration directories in accordance with XDG
specifications.  When unspecified, this variable defaults to F</etc/xdg>
in accordance with XDG specifications.

=item B<XDG_DATA_HOME>

Specifies the user data directory in accordance with XDG specifications.
When unspecified, this variable defaults to F<$HOME/.local/share> in
accordance with XDG specifications.

=item B<XDG_DATA_DIRS>

Specifies the system data directories in accordance with XDG
specifications.
When unspecified, this variable defaults to
F</usr/local/share:/usr/share> in accordance with XDG specifications.

=item B<XDG_ICON_THEME>

Specifies the name of the icon theme.  When not specified, the icon
theme will be determined from configuration sources (e.g.
F<$HOME/.gtkrc-2.0>).

=back

=head1 HISTORY

B<xde-menugen> was written for a number of reasons:

=over

=item 1.

Existing fluxbox menu generators that read XDG .desktop files
(L<fbmenugen(1)>, L<menutray(1)>) do not conform to XDG menu generation
specifications and in particular are incapable of merging menus.

=item 2.

Existing XDG menu generators (such as the SuSE L<xdg_menu(1)> script) do
not properly merge default merge directories and do not observe <Layout>
commands.  Also, they are poor at including icons in the generated menus.

=item 3.

Existing XDG menu generators run once and keep cache information.  They
do not monitor XDG directories for changes and update menus on changes.

=back

=head1 SEE ALSO

L<XDG::Menu(3pm)>, L<XDG::Icons(3pm)>,
L<Linux::Inotify2(3pm)>.

=cut
