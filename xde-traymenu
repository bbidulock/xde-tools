#!/usr/bin/perl

# in case we get executed (not sourced) as a shell program
eval 'exec perl -S $0 ${1+"@"}'
    if $running_under_some_shell;

BEGIN {
    use strict;
    use warnings;
    my $here = $0; $here =~ s{/[^/]*$}{};
    if ($here =~ s{^\.}{}) {
	chomp(my $cwd = `pwd`);
	$here = "/$here" if $here;
	$here = "$cwd$here";
    }
    unshift @INC, "$here/lib" unless $here eq '/usr/bin';
}

=head1 NAME

 xde-traymenu - an XDG compliant system tray menu

=head1 SYNOPSIS

 xde-traymenu [OPTIONS]

=head1 DESCRIPTION

B<xde-traymenu> provides an XDG compliant system tray menu.  The tool is
capable of generating XDG applications menus as well as window-manager
specific menus for a number of window-managers.

=cut

use Getopt::Long;
use Encode;
use I18N::Langinfo qw(langinfo CODESET);
use POSIX qw(locale_h);
use Glib qw(TRUE FALSE);
use Gtk2;
use strict;
use warnings;

my %OVERRIDES = ();
my $here = $0; $here =~ s{/[^/]*$}{};
if ($here =~ s{^\.}{}) {
    chomp(my $cwd = `pwd`);
    $here = "/$here" if $here;
    $here = "$cwd$here";
}
unless ($here eq '/usr/bin') {
    %OVERRIDES = (
	HERE               => "$here",
	XDG_CONFIG_PREPEND => "$here/xdg/xde:$here/xdg",
	XDG_DATA_PREPEND   => "$here/share/xde:$here/share",
	XDG_ICON_APPEND    => "$here/share/icons:$here/share/pixmaps",
    );
    my %path = (map{$_=>1}split(/:/,$ENV{PATH}));
    $ENV{PATH} = "$here:$ENV{PATH}" unless exists $path{$here};
}

if ($here ne '/usr/bin') {
	Gtk2::Rc->set_default_files("$here/themes/Unexicon/gtk-2.0/gtkrc", "$here/gtkrc-2.0");
} else {
	Gtk2::Rc->set_default_files("$ENV{HOME}/.gtkrc-2.0.mine");
}

Gtk2::Rc->parse_string('gtk-theme-name="Squared-blue"'."\n");

Gtk2->init;

require XDG::Menu::Parser;
require XDG::Menu::Tray;

my $HOME = $ENV{HOME} if $ENV{HOME};
$HOME = '~' unless $HOME;

my $XDG_CURRENT_DESKTOP = $ENV{XDG_CURRENT_DESKTOP} if $ENV{XDG_CURRENT_DESKTOP};
$XDG_CURRENT_DESKTOP = '' unless $XDG_CURRENT_DESKTOP;
$ENV{XDG_CURRENT_DESKTOP} = $XDG_CURRENT_DESKTOP if $XDG_CURRENT_DESKTOP;

my $XDG_CONFIG_HOME = $ENV{XDG_CONFIG_HOME} if $ENV{XDG_CONFIG_HOME};
$XDG_CONFIG_HOME = "$HOME/.config" unless $XDG_CONFIG_HOME;
$ENV{XDG_CONFIG_HOME} = $XDG_CONFIG_HOME if $XDG_CONFIG_HOME;

my $XDG_CONFIG_DIRS = $ENV{XDG_CONFIG_DIRS} if $ENV{XDG_CONFIG_DIRS};
$XDG_CONFIG_DIRS = "/etc/xdg" unless $XDG_CONFIG_DIRS;
$ENV{XDG_CONFIG_DIRS} = $XDG_CONFIG_DIRS if $XDG_CONFIG_DIRS;

my @XDG_CONFIG_DIRS = (split(/:/,join(':',$XDG_CONFIG_HOME,$XDG_CONFIG_DIRS)));

my $XDG_DATA_HOME = $ENV{XDG_DATA_HOME} if $ENV{XDG_DATA_HOME};
$XDG_DATA_HOME = "$HOME/.local/share" unless $XDG_DATA_HOME;
$ENV{XDG_DATA_HOME} = $XDG_DATA_HOME if $XDG_DATA_HOME;

my $XDG_DATA_DIRS = $ENV{XDG_DATA_DIRS} if $ENV{XDG_DATA_DIRS};
$XDG_DATA_DIRS = "/usr/local/share:/usr/share" unless $XDG_DATA_DIRS;
$ENV{XDG_DATA_DIRS} = $XDG_DATA_DIRS if $XDG_DATA_DIRS;

my @XDG_DATA_DIRS = (split(/:/,join(':',$XDG_DATA_HOME,$XDG_DATA_DIRS)));

my $XDG_MENU_PREFIX = $ENV{XDG_MENU_PREFIX} if $ENV{XDG_MENU_PREFIX};
$XDG_MENU_PREFIX = '' unless $XDG_MENU_PREFIX;
$ENV{XDG_MENU_PREFIX} = $XDG_MENU_PREFIX if $XDG_MENU_PREFIX;

my $XDG_MENU_NAME = 'applications';

my @XDG_MENU_DIRS = map {"$_/menus"} @XDG_CONFIG_DIRS;

my $XDG_ROOT_MENU = '';
foreach my $name (
	"${XDG_MENU_PREFIX}${XDG_MENU_NAME}.menu",
	"${XDG_MENU_NAME}.menu") {
    foreach (@XDG_MENU_DIRS) {
	if (-f "$_/$name") {
	    $XDG_ROOT_MENU = "$_/$name";
	    last;
	}
    }
    last if $XDG_ROOT_MENU;
}

my $XDG_ICON_THEME = $ENV{XDG_ICON_THEME} if $ENV{XDG_ICON_THEME};
unless ($XDG_ICON_THEME) {
    if (-f "$HOME/.gtkrc-2.0") {
        my @lines = (`cat $ENV{HOME}/.gtkrc-2.0`);
        foreach (@lines) { chomp;
            if (m{gtk-icon-theme-name=["]?(.*[^"])["]?$}) {
                $XDG_ICON_THEME = "$1";
                last;
            }
        }
    } else {
        $XDG_ICON_THEME = 'hicolor';
    }
}
$ENV{XDG_ICON_THEME} = $XDG_ICON_THEME if $XDG_ICON_THEME;

my $XDG_ICON_DIRS = join(':',"$HOME/.icons",map{"$_/icons"}@XDG_DATA_DIRS,'/usr/share/pixmaps');
my @XDG_ICON_DIRS = split(/:/,$XDG_ICON_DIRS);

my %outputs = (
    fluxbox     => [ "$HOME/.fluxbox/menu" ],
    blackbox    => [ "$HOME/.blackbox/menu", "$HOME/.bbmenu" ],
    openbox     => [ "$HOME/.openbox/menu", "$HOME/.config/openbox/menu" ],
    icewm       => [ "$HOME/.icewm/menu" ],
    jwm		=> [ "$HOME/.jwm/menu" ],
    pekwm       => [ "$HOME/.pekwm/menu" ],
);

my %formats = (
    fluxbox     => [qw(FLUXBOX  XDG::Menu::Tray	)],
    blackbox    => [qw(BLACKBOX XDG::Menu::Tray )],
    openbox     => [qw(OPENBOX  XDG::Menu::Tray	)],
    icewm       => [qw(ICEWM    XDG::Menu::Tray	)],
    openbox3    => [qw(LXDE     XDG::Menu::Tray )],
    wmaker      => [qw(WMAKER   XDG::Menu::Tray	)],
    jwm         => [qw(JWM      XDG::Menu::Tray )],
    pekwm       => [qw(PEKWM    XDG::Menu::Tray )],
);

my %desktops = (
    FLUXBOX     => [qw(fluxbox  XDG::Menu::Tray	)],
    BLACKBOX    => [qw(blackbox XDG::Menu::Tray	)],
    WMAKER      => [qw(wmaker   XDG::Menu::Tray	)],
    OPENBOX     => [qw(openbox  XDG::Menu::Tray	)],
    LXDE        => [qw(openbox3 XDG::Menu::Tray )],
    ICEWM       => [qw(icewm    XDG::Menu::Tray	)],
    JWM         => [qw(jwm      XDG::Menu::Tray )],
    PEKWM       => [qw(pekwm    XDG::Menu::Tray )],
);


=head1 OPTIONS

B<xde-traymenu> accepts the following options:

=over

=item B<--help>, B<-h>

Print usage information, including the current values of option
defaults, and exits.

=item B<--verbose>, B<-v>

Print debugging information on standard error during operation.

=item B<--format>, B<-f> I<FORMAT>

Specify the output format.  Recognized output formats are as follows:
C<twm>, C<wmaker>, C<windowmaker>, C<fvwm>, C<fvwm2>, C<fvwm-crystal>,
C<ion3>, C<blackbox>, C<fluxbox>, C<openbox>, C<xfce4>, C<openbox3>,
C<openbox3-pipe>, C<awesome>, C<icewm>, C<jwm>, C<pekwm>.

When unspecified, the setting of the B<XDG_CURRENT_DESKTOP> environment
variable is used to determine the format.  This is accomplished by
converting the value of B<XDG_CURRENT_DESKTOP> to lower-case.  See
L</ENVIRONMENT>.

When the B<XDG_CURRENT_DESKTOP> environment variable is undefined, the X
Display is examined to determine the window-manager in use.  See
L</X RESOURCES>.

=item B<--fullmenu>, B<-F>, B<--nofullmenu>, B<-N>

When specified, output a full menu and not only the application
sub-menu, or not.  The default is to output a full menu.

=item B<--desktop>, B<-d> I<DESKTOP>

Specify the desktop name for C<NotShowIn> and C<OnlyShowIn> comparisons.
The default is the all upper-case value corresponding to the format
unless B<XDG_CURRENT_DESKTOP> is defined (see L</ENVIRONMENT>).

=item B<--charset>, B<-c> I<CHARSET>

Specify the character set with which to output the menu.  Defaults to
the character set in use by the current locale.

=item B<--language>, B<-l> I<LANGUAGE>

Specify the output language for the menu.  Defaults to the language set
in the current locale.

=item B<--root-menu>, B<-r> I<MENU>

Specify the location of the root menu file.  The default is calculated
using XDG environment variables (see L</ENVIRONMENT>), and defaults to
the file F<${XDG_MENU_PREFIX}applications.menu> in the
F<$XDG_CONFIG_HOME:$XDG_CONFIG_DIRS> search path.

=item B<--die-on-error>, B<-e>

Abort output on any error.

=item B<--output>, B<-o> [I<FILENAME>]

Write output to the file, I<FILENAME>.  This is particularly useful with
option B<--die-on-error> as the output will not be written at all if an
error is encountered.  If the I<FILENAME> is not specified, the default
menu location for the current B<--format> will be used.

=item B<--noicons>, B<-n>

Do not include icons in the generated menu files.  This option has no
effect when it is not possible to generate icons for the menu format.
That is, when the B<--format> is one such as C<blackbox>, it is not
possible to place icons in the menu and this option is therefore
ignored.  The default is to place icons in capable generated menus.

=item B<--monitor>, B<-m>

Specifies that B<xde-traymenu> is not to exit after successfully
generating the menu, but to monitor pertinent directories for changes,
and regenerate the menu when changes are detected.  This option implies
the B<--output> option.  This option requires L<Linux::Inotify2(3pm)>.

=back

=cut

my %ops = (
    help	=> '',
    verbose	=> '',
    format	=> "\L$XDG_CURRENT_DESKTOP\E",
    fullmenu	=> '',
    desktop	=> "\U$XDG_CURRENT_DESKTOP\E",
    charset	=> langinfo(CODESET),
    language	=> setlocale(LC_MESSAGES),
    root_menu	=> $XDG_ROOT_MENU,
    die_on_error=> '',
    output	=> '',
    icons	=> '',
    noicons	=> '',
    theme	=> $XDG_ICON_THEME,
    monitor	=> '',
);

my $syntax = GetOptions(
    "help|h"	    =>\$ops{help},
    "verbose|v"	    =>\$ops{verbose},
    "format|f=s"    =>\$ops{format},
    "fullmenu|F!"   =>\$ops{fullmenu},
    "N"		    =>sub{$ops{fullmenu}=0},
    "desktop|d=s"   =>\$ops{desktop},
    "charset|c=s"   =>\$ops{charset},
    "language|l=s"  =>\$ops{language},
    "root-menu|r=s" =>\$ops{root_menu},
    "die-on-error|e"=>\$ops{die_on_error},
    "output|o:s"    =>\$ops{output},
    "icons!"	    =>\$ops{icons},
    "n"		    =>sub{$ops{icons}=0},
    "theme|t=s"	    =>\$ops{theme},
    "monitor|m"	    =>\$ops{monitor},
);

if ($ops{output} eq '') {
    if (exists $outputs{$ops{format}}) {
        foreach (@{$outputs{$ops{format}}}) {
            if (-f $_) {
                $ops{output} = $_;
                last;
            }
        }
    }
}

if ($ops{root_menu} and not -f $ops{root_menu}) {
    $ops{root_menu} = $XDG_ROOT_MENU
        if $XDG_ROOT_MENU and -f $XDG_ROOT_MENU;
}

unless ($ops{format}) {
    $ops{format} = $desktops{$ops{desktop}}[0]
        if $ops{desktop} and $desktops{$ops{desktop}};
}
unless ($ops{desktop}) {
    $ops{desktop} = $formats{$ops{format}}[0]
        if $ops{format} and $formats{$ops{format}};
}

if ($ops{help} or not $syntax) {
    usage($syntax ? 0 : 2);
}

unless ($ops{root_menu} and -f $ops{root_menu}) {
    print STDERR "bad root menu $ops{root_menu}\n" if $ops{root_menu};
    print STDERR "missing root menu\n" unless $ops{root_menu};
    usage(2);
}

unless ($ops{format} and exists $formats{$ops{format}}) {
    print STDERR "bad format $ops{format}\n" if $ops{format};
    print STDERR "missing format\n" unless $ops{format};
    usage(2);
}

unless ($ops{desktop} and exists $desktops{$ops{desktop}}) {
    print STDERR "bad desktop $ops{desktop}\n" if $ops{desktop};
    print STDERR "missing desktop\n" unless $ops{desktop};
    usage(2);
}

if (($ops{desktop} ne $formats{$ops{format}}[0]) or
    ($ops{format} ne $desktops{$ops{desktop}}[0])) {
    print STDERR "mismatch between format $ops{format} and desktop $ops{desktop}\n";
    usage(2);
}

if ($ops{theme}) {
    my $theme = '';
    foreach (@XDG_ICON_DIRS) {
        $theme = $ops{theme} if -f "$_/$ops{theme}/index.theme";
        last if $theme;
    }
    unless ($theme) {
        print STDERR "invalid theme $ops{theme}\n";
        usage(2);
    }
}
else {
    print STDERR "missing theme\n";
    usage(2);
}

$ops{lang} = $ops{language};
$ops{lang} =~ s/\..*$//;

if ($ops{verbose}) {
    print STDERR "\tRoot menu: $ops{root_menu}\n";
    print STDERR "\tFormat:    $ops{format}\n";
    print STDERR "\tDesktop:   $ops{desktop}\n";
    print STDERR "\tTheme:     $ops{theme}\n";
    print STDERR "\tCharset:   $ops{charset}\n";
    print STDERR "\tLanguage:  $ops{language}\n";
    print STDERR "\tLang:      $ops{lang}\n";
}

sub usage {
    my $retval = shift;
    print STDERR<<EOF;
USAGE:
    xde-traymenu [OPTIONS]

OPTIONS:
    --help,-h
        print this usage info and exit

    --format,-f FORMAT      [default: $ops{format}]
        specify the output format to use; defaults to the lowercase
        value of XDG_CURRENT_DESKTOP.

    --fullmenu,-F
        generate a full menu instead of a submenu; default is to
        generate a full menu.

    --nofullmenu,-N
	generate a submenu instead of a full menu; default is to
	generate a full menu.

    --desktop,-d DESKTOP    [default: $ops{desktop}]
        specify the desktop string for OnlyShowIn and NotShowIn desktop
        entries; defaults is XDG_CURRENT_DESKTOP or the uppercase FORMAT
        value.

    --charset,-c CHARSET    [default: $ops{charset}]
        specify the character set to use to output the menu; defaults to
        the charset of the current locale.

    --language,-l LANGUAGE  [default: $ops{language}]
        specify the language to use to output the menu; defaults to the
        value of the current locale.

    --root-menu,-r ROOTMENU [default: $ops{root_menu}]
        specify the root menu.  Default is derived from XDG_MENU_PREFIX
        and XDG_CONFIG_DIRS.

    --die-on-error,-e
        abort (do not write output) on any error.

    --verbose,-v
        print debugging information on standard error.

    --output,-o [FILENAME]  [default: $ops{output}]
        print the output to file, FILENAME; default is to print the menu
        to standard output; default FILENAME if unspecified based on
        format.

    --noicons,-n
        do not include icons in the generated menu; default is to
        include icons in capable menus.

    --theme,-t THEME        [default: $ops{theme}]
        use the specified icon theme when generating icons; defaults to
        the user icon theme.

    --monitor,-m
        do not exit after first menu generation, but monitor pertinent
        directories for changes and regenerate the menu when required;
        implies the --output option.
EOF
    exit($retval);
}

my $style = Gtk2::RcStyle->new;
my @colors = (
    Gtk2::Gdk::Color->new(0x16*257,0x16*257,0x16*257), # 0
    Gtk2::Gdk::Color->new(0x37*257,0x37*257,0x37*257), # 1
    Gtk2::Gdk::Color->new(0x46*257,0x72*257,0x77*257), # 2
    Gtk2::Gdk::Color->new(0x4c*257,0x4c*257,0x4c*257), # 3
    Gtk2::Gdk::Color->new(0x9c*257,0x9c*257,0x9c*257), # 4
    Gtk2::Gdk::Color->new(0xc0*257,0xc0*257,0xc0*257), # 5
    Gtk2::Gdk::Color->new(0xff*257,0xff*257,0xff*257), # 6
);
my %colors = (
    base => {
	normal	    => $colors[0],
	active	    => $colors[2],
	prelight    => $colors[2],
	selected    => $colors[2],
	insensitive => $colors[0],
    },
    bg => {
	normal	    => $colors[0],
	active	    => $colors[2],
	prelight    => $colors[2],
	selected    => $colors[2],
	insensitive => $colors[0],
    },
    fg => {
	normal	    => $colors[6],
	active	    => $colors[5],
	prelight    => $colors[5],
	selected    => $colors[5],
	insensitive => $colors[6],
    },
    text => {
	normal	    => $colors[6],
	active	    => $colors[5],
	prelight    => $colors[5],
	selected    => $colors[5],
	insensitive => $colors[6],
    },
);

my $font = Pango::FontDescription->from_string('Liberation Sans 8');
$style->font_desc($font);
#$style->name('default');

foreach my $state (qw(normal active prelight selected insensitive)) {
    $style->color_flags($state,[qw(base fg bg text)]);
    $style->base($state,$colors{'base'}{$state});
    $style->bg($state,$colors{'bg'}{$state});
    $style->fg($state,$colors{'fg'}{$state});
    $style->text($state,$colors{'text'}{$state});
}

my $parser = new XDG::Menu::Parser;
my $tree = $parser->parse_menu($ops{root_menu});
my $tray = new XDG::Menu::Tray;
$tray->{style} = $style;
$tray->{colors} = \@colors;
my $menu = $tray->create($tree);

my $icon = new Gtk2::StatusIcon->new_from_icon_name('redhat-starthere');
$icon->set_tooltip_text('Click for menu...');
$icon->set_visible(1);
$icon->signal_connect(button_press_event=>sub{
    my ($icon,$ev) = @_;
    my $button = $ev->button;
    return Gtk2::EVENT_PROPAGATE unless $button == 1 or $button == 2 or $button == 3;
    my $time = $ev->time;
    my $menu = $tray->create($tree);
    $menu->popup(undef,undef,undef,undef,$button,$time);
    return Gtk2::EVENT_STOP;
});
$icon->signal_connect(popup_menu=>sub{
    my ($icon,$button,$time) = @_;
#    Gtk2::Rc->parse_string('gtk-theme-name="Squared-green"'."\n");
#    Gtk2::Rc->reset_styles('gtk-theme-name');
#    Gtk2::Rc->reparse_all;
    my $menu = $tray->create($tree);
    $menu->popup(undef,undef,undef,undef,$button,$time);
    return Gtk2::EVENT_PROPAGATE;
});
$icon->signal_connect(activate=>sub{
    my ($icon) = @_;
    return Gtk2::EVENT_PROPAGATE;
	
});
$icon->signal_connect(query_tooltip=>sub{
    my ($icon,$x,$y,$bool,$tooltip) = @_;
    return Gtk2::EVENT_PROPAGATE;
});

Gtk2->main;

=head1 X RESOURCES

B<xde-traymenu> examines and interprets the following X Resources
(atoms).

=over

=item B<_BLACKBOX_PID>

This atom is checked on the root window.  If set, then the window
manager in use is I<Fluxbox>. (Note that I<Blackbox> does not set this
poorly named atom.)

=item B<_OPENBOX_PID>

This atom is checked on the root window.  If set, then the window
manager in use is I<Openbox>.  Additional resources set by the Openbox
window manager on the root window include B<_OB_CONFIG_FILE> and
B<_OB_VERSION>.  The B<_OB_VERSION> in particular can be used to
determine whether C<openbox3> or C<openbox3-pipe> format should be used
instead of B<openbox> format.

=item B<_NET_SUPPORTING_WM_CHECK>

This atom is checked on the root window of the display to determine
which window manager is active.

=item B<_NET_WM_NAME>

This atom is checked on the window indicated by
B<_NET_SUPPORTING_WM_CHECK> to determine the window manager in use.
I<Fluxbox> sets this to I<Fluxbox>; I<Blackbox> to I<Blackbox>, I<IceWM>
to I<IceWM> followed by a version and compile string; I<Openbox> to
I<Openbox>.

=back

=cut

=head1 ENVIRONMENT

The following environment variables are significant to the operation of
B<xde-traymenu>:

=over

=item B<XDG_CURRENT_DESKTOP>

Specifies the current desktop.  When the B<--format> is not specified,
the format defaults to the value of this environment variable converted
to lower-case.  When the B<--desktop> is not specified, the desktop
defaults to the value of this environment variable.

=item B<XDG_MENU_PREFIX>

Specifies the prefix to apply to the default menu name to derive the
root menu unless specified with the B<--root-menu>.  When unspecified,
this variable defaults to a null string.

B<xde-traymenu> finds the root menu using the following logic:

=over

=item 1.

If a file name is specified using the B<--root-menu> option, that file
name is used as the root menu.

=item 2.

If not found, the file name F<${XDG_MENU_PREFIX}applications.menu> is
sought in each of the directories in the path F<@XDG_CONFIG_DIRS/menus>.

=item 3.

If not found, the file name F<applications.menu> is sought in each of
the directories in the path F<@XDG_CONFIG_DIRS/menus>.

=back

=item B<XDG_CONFIG_HOME>

Specifies the user XDG configuration directory.
When unspecified, defaults to F<$HOME/.config> in accordance with XDG
specifications.

=item B<XDG_CONFIG_DIRS>

Specifies the system XDG configuration directories.
When unspecified, defaults to F</etc/xdg> in accordance with XDG
specifications.

=item B<XDG_DATA_HOME>

Specifies the user XDG data directory.
When unspecified, defaults to F<$HOME/.local/share> in accordance with
XDG specifications.

=item B<XDG_DATA_DIRS>

Specifies the system XDG data directories.
When unspecified, defaults to F</usr/local/share:/usr/share> in
accordance with XDG specifications.

=item B<XDG_ICON_THEME>

Specifies the name of the icon theme.  When not specified, the icon
theme will be determined from configuration sources (e.g.
F<$HOME/.gtkrc-2.0>).

=back

=cut

=head1 HISTORY

I wrote B<xde-traymenu> for a number of reasons:

=over

=item 1.

Existing fluxbox menu generators that read XDG .desktop files
(L<menutray(1)>) do not conform to XDG menu generation specifications
and in particular are incapable of merging menus.

=item 2.

Existing XDG menu generators (such as the SuSE L<xdg_menu(1)> script) do
not properly merge default merge directories and do no observe <Layout>
commands.  Also, they are poor at including icons in the generated
menus.  They, of course, do not generate tray menus either.

=item 3.

Existing XDG menu generators run once and keep cache information, or
have a I<regenerate> command placed in the menu.  They do not monitor
XDG directories for changes and update menus on changes.

=item 4.

The L<lxpanel(1)> and L<pcmanfm(1)> menu generators do not have any of
the above deficiencies; however, they do not create window manager
specific submenus.

=back

=cut

